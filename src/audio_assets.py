# File to quickly generate zig code for array of all game audio assets, based on folder structure.
# Similarly to how visual assets are handeled, but simpler.

from os import path, scandir

FILE_HEADER = (
    """\
/// File generated by """
    + path.split(__file__)[-1]
    + """ - Manual changes will probably be overwritten.
const StaticMap = @import("utils.zig").StaticMap;
const fields = @import("std").meta.fields;
const print = @import("std").debug.print;

pub const WavFile = struct {
    start_ptr: ?*u8,
    length: u32,
};

pub const AudioAsset = struct {
    path: [:0]const u8,
    id: ID,
};
"""
)

ENUM_HEADER = """\
pub const ID = enum(u16) {
"""

ENUM_FOOTER = """\

    pub inline fn int(comptime id: ID) u16 {
        return @intFromEnum(id);
    }

    pub inline fn size() u16 {
        return fields(ID).len;
    }
};
"""


ASSETS_PRE_HEADER = "pub const ALL: ["

ASSETS_POST_HEADER = "]AudioAsset = .{\n"

ASSETS_FOOTER = """\
};
"""

BACKING_INTEGER = "u16"

# Run this file from the project root (i.e. the battlebuds/ directory).
# Update: script is automatically called from build.zig now.
if __name__ == "__main__":
    print("\nRUNNING:", __file__, "\n")
    TAB_SIZE = 4
    asset_dir = "assets/audio"
    output_file = "src/audio_assets.zig"

    with open(output_file, "w") as outfile:
        print(FILE_HEADER, file=outfile)

        enum_string = ENUM_HEADER
        assets_string = ""
        audio_assets_per_id = []
        wavfile_array_names = []

        total_num_assets = 0
        for asset_type_dir in scandir(asset_dir):
            if not asset_type_dir.is_dir():
                continue

            asset_type = asset_type_dir.name

            for asset_subtype_dir in scandir(asset_type_dir.path):
                if not asset_subtype_dir.is_dir():
                    continue

                asset_subtype = asset_subtype_dir.name

                has_sounds = False
                for sound_dir in scandir(asset_subtype_dir.path):
                    if not sound_dir.is_dir():
                        continue

                    has_sounds = True
                    sound = sound_dir.name
                    id = (
                        asset_type.upper()
                        + "_"
                        + asset_subtype.upper()
                        + "_"
                        + sound.upper()
                    )
                    num_assets = 0

                    # We sort sound variations by name in case we want some ordered playing of a sound group.
                    def sort_query(wav_file) -> int:
                        return int(wav_file.name.strip(".wav"))

                    for sound_variation in sorted(scandir(sound_dir.path), key=sort_query):
                        if not sound_variation.is_file():
                            continue

                        num_assets += 1
                        assets_string += (
                            '\t.{ .path = "'
                            + path.relpath(sound_variation.path, ".")
                            + '", .id = .'
                            + id
                            + " },\n"
                        )

                    if num_assets > 0:
                        enum_string += "\t" + id + ",\n"
                        audio_assets_per_id.append(num_assets)
                        wavfile_array_names.append(id.lower() + "_wavfiles")
                        total_num_assets += num_assets

        enum_string += ENUM_FOOTER
        print(enum_string.expandtabs(TAB_SIZE), file=outfile)

        assets_string = (
            ASSETS_PRE_HEADER
            + str(total_num_assets)
            + ASSETS_POST_HEADER
            + assets_string
        )
        assets_string += ASSETS_FOOTER
        print(assets_string.expandtabs(TAB_SIZE), file=outfile)

        audio_assets_per_id_string = (
            "pub const ASSETS_PER_ID: [ID.size()]usize = .{ "
            + str(audio_assets_per_id)[1:-1]
            + " };\n"
        )
        print(audio_assets_per_id_string.expandtabs(TAB_SIZE), file=outfile)

        print("// Storage for .wav files to be initialized at runtime.", file=outfile)
        for size, array_name in zip(audio_assets_per_id, wavfile_array_names):
            print(
                "var " + array_name + ": [" + str(size) + "]WavFile = undefined;",
                file=outfile,
            )

        print("\npub var wavfile_slices: [ID.size()][]WavFile = .{", file=outfile)
        for array_name in wavfile_array_names:
            print(("\t&" + array_name + ",").expandtabs(TAB_SIZE), file=outfile)
        print("};", file=outfile)
